package engine

import (
	"context"
	"testing"
	"time"

	"github.com/rmax-ai/ratelord/pkg/engine/forecast"
	"github.com/rmax-ai/ratelord/pkg/provider"
	"github.com/rmax-ai/ratelord/pkg/store"
)

// MockProvider implements provider.Provider for testing
type MockProvider struct {
	IDVal       provider.ProviderID
	PollResult  provider.PollResult
	PollErr     error
	RestoreFunc func([]byte) error
}

func (m *MockProvider) ID() provider.ProviderID {
	return m.IDVal
}

func (m *MockProvider) Poll(ctx context.Context) (provider.PollResult, error) {
	return m.PollResult, m.PollErr
}

func (m *MockProvider) Restore(state []byte) error {
	if m.RestoreFunc != nil {
		return m.RestoreFunc(state)
	}
	return nil
}

func TestPoller_Poll(t *testing.T) {
	st, err := store.NewStore(":memory:")
	if err != nil {
		t.Fatalf("Failed to create store: %v", err)
	}
	defer st.Close()

	// Setup Forecaster
	fore := forecast.NewForecaster(st, forecast.NewForecastProjection(10), nil)

	poller := NewPoller(st, time.Hour, fore, &PolicyConfig{})

	// Setup Mock Provider
	mock := &MockProvider{
		IDVal: "mock-provider",
		PollResult: provider.PollResult{
			ProviderID: "mock-provider",
			Timestamp:  time.Now(),
			Status:     "ok",
			Usage: []provider.UsageObservation{
				{
					PoolID:    "pool-1",
					Used:      100,
					Remaining: 900,
				},
			},
		},
	}
	poller.Register(mock)

	// Trigger poll manually
	poller.poll(context.Background(), mock)

	// Verify events in store
	events, err := st.ReadRecentEvents(context.Background(), 10)
	if err != nil {
		t.Fatalf("Failed to read events: %v", err)
	}
	// Note: We might get varying number of events if previous tests polluted DB? No, this is fresh memory DB.
	// Expected: 1 poll event + 1 usage event = 2.
	if len(events) != 2 {
		t.Fatalf("Expected 2 events (poll + usage), got %d", len(events))
	}

	// Verify types
	foundPoll := false
	foundUsage := false
	for _, evt := range events {
		if evt.EventType == store.EventTypeProviderPollObserved {
			foundPoll = true
		} else if evt.EventType == store.EventTypeUsageObserved {
			foundUsage = true
		}
	}

	if !foundPoll {
		t.Error("Missing poll observed event")
	}
	if !foundUsage {
		t.Error("Missing usage observed event")
	}
}

func TestPoller_RestoreProviders(t *testing.T) {
	st, _ := store.NewStore(":memory:")
	defer st.Close()

	poller := NewPoller(st, time.Hour, nil, nil)

	restored := false
	mock := &MockProvider{
		IDVal: "prov-restore",
		RestoreFunc: func(state []byte) error {
			if string(state) == "saved-state" {
				restored = true
			}
			return nil
		},
	}
	poller.Register(mock)

	// Mock lookup function
	lookup := func(id provider.ProviderID) []byte {
		if id == "prov-restore" {
			return []byte("saved-state")
		}
		return nil
	}

	poller.RestoreProviders(lookup)

	if !restored {
		t.Error("Provider restore not called with correct state")
	}
}

func TestPoller_PollAll(t *testing.T) {
	st, _ := store.NewStore(":memory:")
	defer st.Close()

	poller := NewPoller(st, time.Hour, nil, nil)

	mock1 := &MockProvider{
		IDVal: "p1",
		PollResult: provider.PollResult{
			ProviderID: "p1",
			Usage:      []provider.UsageObservation{},
		},
	}
	// We can't easily hook into Poll execution without modifying MockProvider to track calls
	// So let's rely on events or modify MockProvider.
	// But MockProvider.Poll just returns result.
	// Let's check events.

	poller.Register(mock1)

	mock2 := &MockProvider{
		IDVal: "p2",
		PollResult: provider.PollResult{
			ProviderID: "p2",
			Usage:      []provider.UsageObservation{},
		},
	}
	poller.Register(mock2)

	poller.pollAll(context.Background())

	events, _ := st.ReadRecentEvents(context.Background(), 10)
	if len(events) != 2 {
		t.Errorf("Expected 2 poll events, got %d", len(events))
	}
}

func TestPoller_Start(t *testing.T) {
	st, _ := store.NewStore(":memory:")
	defer st.Close()

	poller := NewPoller(st, 1*time.Millisecond, nil, nil) // Fast interval

	mock := &MockProvider{
		IDVal: "p1",
		PollResult: provider.PollResult{
			ProviderID: "p1",
			Usage:      []provider.UsageObservation{},
		},
	}
	poller.Register(mock)

	ctx, cancel := context.WithCancel(context.Background())

	done := make(chan struct{})
	go func() {
		poller.Start(ctx)
		close(done)
	}()

	// Wait for at least one tick
	time.Sleep(10 * time.Millisecond)
	cancel()

	select {
	case <-done:
		// Success
	case <-time.After(1 * time.Second):
		t.Fatal("Poller did not stop")
	}

	// Verify at least one event (poll observed)
	events, _ := st.ReadRecentEvents(context.Background(), 10)
	if len(events) == 0 {
		t.Error("Expected events generated by background poller")
	}
}

func TestPoller_ConfigAndHelpers(t *testing.T) {
	st, _ := store.NewStore(":memory:")
	defer st.Close()
	poller := NewPoller(st, time.Hour, nil, nil)

	// UpdateConfig
	cfg := &PolicyConfig{Pricing: map[string]map[string]int64{"p": {"u": 1}}}
	poller.UpdateConfig(cfg)
	poller.mu.RLock()
	if poller.policyCfg != cfg {
		t.Error("UpdateConfig failed")
	}
	poller.mu.RUnlock()

	// SetEpochFunc
	poller.SetEpochFunc(func() int64 { return 123 })
	if poller.getEpoch() != 123 {
		t.Errorf("getEpoch returned %d, expected 123", poller.getEpoch())
	}

	// GetProvider
	mock := &MockProvider{IDVal: "p1"}
	poller.Register(mock)
	if p := poller.GetProvider("p1"); p != mock {
		t.Error("GetProvider returned wrong provider")
	}
	if p := poller.GetProvider("non-existent"); p != nil {
		t.Error("GetProvider should return nil for missing provider")
	}
}
